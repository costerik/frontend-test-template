import * as path from 'node:path';
import { $ } from 'execa';
import fsExtra from 'fs-extra';
import { glob } from 'glob';
import { parse } from 'node-html-parser';

const main = async () => {
  const cwd = process.cwd();
  const inputDir = path.join(cwd, 'assets', 'svgs');
  const inputDirRelative = path.relative(cwd, inputDir);
  const outputDir = path.join(cwd, 'public', 'images', 'icons');
  const typeDir = path.join(cwd, 'src', 'components', 'Icon');
  await fsExtra.ensureDir(outputDir);

  const files = glob
    .sync('**/*.svg', {
      cwd: inputDir,
    })
    .sort((a, b) => {
      return a.localeCompare(b);
    });

  const shouldVerboseLog = process.argv.includes('--log=verbose');
  const logVerbose = shouldVerboseLog ? console.log : () => {};

  function iconName(file: string) {
    return file.replace(/\.svg$/, '');
  }

  async function writeIfChanged(filepath: string, newContent: string) {
    const currentContent = await fsExtra
      .readFile(filepath, 'utf8')
      .catch(() => '');
    if (currentContent === newContent) return false;
    await fsExtra.writeFile(filepath, newContent, 'utf8');
    await $`prettier --write ${filepath} --ignore-unknown`;
    return true;
  }

  /**
   * Creates a single SVG file that contains all the icons
   */
  async function generateSvgSprite({
    svgFiles,
    svgInputDir,
    outputPath,
  }: {
    svgFiles: string[];
    svgInputDir: string;
    outputPath: string;
  }) {
    const symbols = await Promise.all(
      svgFiles.map(async (file) => {
        const input = await fsExtra.readFile(
          path.join(svgInputDir, file),
          'utf8',
        );

        const root = parse(input);
        const svg = root.querySelector('svg');

        if (!svg) throw new Error('No SVG element found');

        svg.tagName = 'symbol';

        svg.setAttribute('id', iconName(file));
        svg.removeAttribute('xmlns');
        svg.removeAttribute('xmlns:xlink');
        svg.removeAttribute('version');
        svg.removeAttribute('width');
        svg.removeAttribute('height');

        return svg.toString().trim();
      }),
    );

    const output = [
      `<?xml version="1.0" encoding="UTF-8"?>`,
      `<!-- This file is generated by npm run build:icons -->`,
      `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
      `<defs>`, // For semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
      ...symbols,
      `</defs>`,
      `</svg>`,
      '', // Trailing newline
    ].join('\n');

    return writeIfChanged(outputPath, output);
  }

  async function generateIconFiles() {
    const spriteFilepath = path.join(outputDir, 'sprite.svg');
    const typeOutputFilepath = path.join(typeDir, 'Icon.types.ts');
    const currentSprite = await fsExtra
      .readFile(spriteFilepath, 'utf8')
      .catch(() => {
        return '';
      });
    const currentTypes = await fsExtra
      .readFile(typeOutputFilepath, 'utf8')
      .catch(() => {
        return '';
      });

    const iconNames = files.map((file) => {
      return iconName(file);
    });

    const spriteUpToDate = iconNames?.every((name) => {
      return currentSprite.includes(`id=${name}`);
    });
    const typesUpToDate = iconNames?.every((name) => {
      return currentTypes.includes(`"${name}"`);
    });

    if (spriteUpToDate && typesUpToDate) {
      logVerbose(`Icons are up to date`);
      return;
    }

    logVerbose(`Generating sprite for ${inputDirRelative}`);

    const spriteChanged = await generateSvgSprite({
      svgFiles: files,
      svgInputDir: inputDir,
      outputPath: spriteFilepath,
    });

    for (const file of files) {
      logVerbose('âœ…', file);
    }
    logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

    const stringifiedIconNames = iconNames.map((name) => {
      return JSON.stringify(name);
    });

    const typeOutputContent = `// This file is generated by npm run build:icons

export type IconName =
\t| ${stringifiedIconNames.join('\n\t| ')};

export const iconNames = [${stringifiedIconNames.join(',')}]
`;
    const typesChanged = await writeIfChanged(
      typeOutputFilepath,
      typeOutputContent,
    );

    logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

    const readmeChanged = await writeIfChanged(
      path.join(outputDir, 'README.md'),
      `# Icons

This directory contains SVG icons that are used by the app.

Everything in this directory is generated by \`npm run build:icons\`.
`,
    );

    if (spriteChanged || typesChanged || readmeChanged) {
      console.log(`Generated ${files.length} icons`);
    }
  }

  if (files.length === 0) {
    console.log(`No SVG files found in ${inputDirRelative}`);
  } else {
    await generateIconFiles();
  }
};

main();
